#ifndef STDDLL
#define STDDLL

// @author: htcdevk0

//
// Last patch [1.1.0]:
// Added std::vector support
//

#include <string>
#include <memory>
#include <functional>
#include <stdexcept>
#include <iostream>
#include <unordered_map>
#include <vector>

#if defined(_WIN32) || defined(_WIN64)
#include <windows.h>
#define STDDLL_WIN
#else
#include <dlfcn.h>
#define STDDLL_POSIX
#endif

#define STDDLL_VERSION "1.1.0"

namespace stddll
{

    namespace detail
    {
        template <typename T>
        struct is_std_vector : std::false_type
        {
        };

        template <typename T, typename A>
        struct is_std_vector<std::vector<T, A>> : std::true_type
        {
        };
    }

    template <typename T>
    constexpr bool is_std_vector = detail::is_std_vector<T>::value;

#ifdef STDDLL_WIN
#define DLL_EXPORT __declspec(dllexport)
#define DLL_IMPORT __declspec(dllimport)
#else
#define DLL_EXPORT __attribute__((visibility("default")))
#define DLL_IMPORT
#endif

#define EXPORT extern "C" DLL_EXPORT

#define EXPORT_VECTOR(type, name, size, ...) \
    EXPORT type name[size] = {__VA_ARGS__}; \
    EXPORT size_t name##_size = (size)

#define EXPORT_DYNAMIC_VECTOR(type, name) \
    EXPORT type *name = nullptr;          \
    EXPORT size_t name##_size = 0;        \
    EXPORT void name##_init(size_t n)     \
    {                                     \
        if (name)                         \
            delete[] name;                \
        name = new type[n];               \
        name##_size = n;                  \
    }                                     \
    EXPORT void name##_free()             \
    {                                     \
        if (name)                         \
            delete[] name;                \
        name = nullptr;                   \
        name##_size = 0;                  \
    }

#define EXPORT_CLASS(T)                                       \
    extern "C" DLL_EXPORT T *create_##T() { return new T(); } \
    extern "C" DLL_EXPORT void destroy_##T(T *obj) { delete obj; }

    class DLL
    {
    private:
#ifdef STDDLL_WIN
        HMODULE handle = nullptr;
#else
        void *handle = nullptr;
#endif
        std::string path;

    public:
        explicit DLL(const std::string &dll_path) : path(dll_path)
        {
#ifdef STDDLL_WIN
            handle = LoadLibraryA(dll_path.c_str());
            if (!handle)
                throw std::runtime_error("Failed to load: " + dll_path);
#else
            handle = dlopen(dll_path.c_str(), RTLD_LAZY | RTLD_LOCAL);
            if (!handle)
                throw std::runtime_error(dlerror());
#endif
        }

        ~DLL() noexcept
        {
            if (handle)
            {
#ifdef STDDLL_WIN
                FreeLibrary(handle);
#else
                dlclose(handle);
#endif
            }
        }

        DLL(const DLL &) = delete;
        DLL &operator=(const DLL &) = delete;

        DLL(DLL &&other) noexcept : handle(other.handle), path(std::move(other.path))
        {
            other.handle = nullptr;
        }

        DLL &operator=(DLL &&other) noexcept
        {
            if (this != &other)
            {
                if (handle)
                {
#ifdef STDDLL_WIN
                    FreeLibrary(handle);
#else
                    dlclose(handle);
#endif
                }
                handle = other.handle;
                path = std::move(other.path);
                other.handle = nullptr;
            }
            return *this;
        }

        template <typename T>
        auto get(const std::string &name) const
        {
            if (!handle)
            {
                if constexpr (std::is_function_v<T>)
                {
                    using FuncPtr = T *;
                    return static_cast<FuncPtr>(nullptr);
                }
                else if constexpr (std::is_pointer_v<T>)
                {
                    return static_cast<T>(nullptr);
                }
                else
                {
                    return T{};
                }
            }

#ifdef STDDLL_WIN
            void *ptr = reinterpret_cast<void *>(
                GetProcAddress(handle, name.c_str()));
#else
            void *ptr = dlsym(handle, name.c_str());
#endif

            if (!ptr)
            {
                std::cerr << "Symbol '" << name << "' not found in " << path << std::endl;

                if constexpr (std::is_function_v<T>)
                {
                    using FuncPtr = T *;
                    return static_cast<FuncPtr>(nullptr);
                }
                else if constexpr (std::is_pointer_v<T>)
                {
                    return static_cast<T>(nullptr);
                }
                else
                {
                    return T{};
                }
            }

            if constexpr (is_std_vector<T>)
            {
                using ValueType = typename T::value_type;
                ValueType *data_ptr = reinterpret_cast<ValueType *>(ptr);
                size_t size = 0;

                void *size_ptr = nullptr;
#ifdef STDDLL_WIN
                size_ptr = reinterpret_cast<void *>(GetProcAddress(handle, (name + "_size").c_str()));
#else
                size_ptr = dlsym(handle, (name + "_size").c_str());
#endif

                if (size_ptr)
                {
                    size = *reinterpret_cast<size_t *>(size_ptr);
                }

                return T(data_ptr, data_ptr + size);
            }
            else if constexpr (std::is_function_v<T>)
            {
                using FuncPtr = T *;
                return reinterpret_cast<FuncPtr>(ptr);
            }
            else if constexpr (std::is_pointer_v<T>)
            {
                return reinterpret_cast<T>(ptr);
            }
            else
            {
                return *reinterpret_cast<T *>(ptr);
            }
        }

        template <typename Func>
        Func *operator()(const std::string &function_name) const
        {
            return get<Func>(function_name);
        }

        operator bool() const { return handle != nullptr; }

        const std::string &name() const { return path; }
    };

    inline DLL load(const std::string &dll_path)
    {
        return DLL(dll_path);
    }

    class DLLManager
    {
    private:
        std::unordered_map<std::string, DLL> dlls;

    public:
        DLL &load(const std::string &name, const std::string &path)
        {
            return dlls.emplace(name, DLL(path)).first->second;
        }

        DLL &get(const std::string &name)
        {
            auto it = dlls.find(name);
            if (it == dlls.end())
                throw std::runtime_error("DLL not loaded: " + name);
            return it->second;
        }

        void unload(const std::string &name)
        {
            dlls.erase(name);
        }

        bool has(const std::string &name) const
        {
            return dlls.find(name) != dlls.end();
        }

        void clear()
        {
            dlls.clear();
        }
    };

    inline DLLManager &dlls()
    {
        static DLLManager manager;
        return manager;
    }

    inline DLL &load_to(const std::string &name, const std::string &path)
    {
        return dlls().load(name, path);
    }

}

#define EASY_DLL(var_name, dll_path) auto var_name = stddll::load(dll_path)
#define GET_FUNC(dll, return_type, func_name, ...) \
    dll.get<return_type (*)(__VA_ARGS__)>(#func_name)
#define CALL(dll, func, ...) \
    dll.get<decltype(func) *>(#func)(__VA_ARGS__)

#endif