#ifndef STDDLL
#define STDDLL

// @author: htcdevk0

#include <string>
#include <memory>
#include <functional>
#include <stdexcept>
#include <iostream>
#include <unordered_map>

#if defined(_WIN32) || defined(_WIN64)
#include <windows.h>
#define STDDLL_WIN
#else
#include <dlfcn.h>
#define STDDLL_POSIX
#endif

#define STDDLL_VERSION "1.0.0"

namespace stddll
{

#ifdef STDDLL_WIN
#define DLL_EXPORT __declspec(dllexport)
#define DLL_IMPORT __declspec(dllimport)
#else
#define DLL_EXPORT __attribute__((visibility("default")))
#define DLL_IMPORT
#endif

#define EXPORT extern "C" DLL_EXPORT

#define EXPORT_CLASS(T)                                       \
    extern "C" DLL_EXPORT T *create_##T() { return new T(); } \
    extern "C" DLL_EXPORT void destroy_##T(T *obj) { delete obj; }

class DLL
{
private:
#ifdef STDDLL_WIN
    HMODULE handle = nullptr;
#else
    void *handle = nullptr;
#endif
    std::string path;

public:
    explicit DLL(const std::string &dll_path) : path(dll_path)
    {
#ifdef STDDLL_WIN
        handle = LoadLibraryA(dll_path.c_str());
        if (!handle)
            throw std::runtime_error("Failed to load: " + dll_path);
#else
        handle = dlopen(dll_path.c_str(), RTLD_LAZY | RTLD_LOCAL);
        if (!handle)
            throw std::runtime_error(dlerror());
#endif
    }

    ~DLL() noexcept
    {
        if (handle)
        {
#ifdef STDDLL_WIN
            FreeLibrary(handle);
#else
            dlclose(handle);
#endif
        }
    }

    DLL(const DLL &) = delete;
    DLL &operator=(const DLL &) = delete;

    DLL(DLL &&other) noexcept : handle(other.handle), path(std::move(other.path))
    {
        other.handle = nullptr;
    }

    DLL &operator=(DLL &&other) noexcept
    {
        if (this != &other)
        {
            if (handle)
            {
#ifdef STDDLL_WIN
                FreeLibrary(handle);
#else
                dlclose(handle);
#endif
            }
            handle = other.handle;
            path = std::move(other.path);
            other.handle = nullptr;
        }
        return *this;
    }

    template <typename Func>
    Func *get(const std::string &function_name) const
    {
        if (!handle)
            return nullptr;

#ifdef STDDLL_WIN
        void *func = reinterpret_cast<void *>(
            GetProcAddress(handle, function_name.c_str()));
#else
        void *func = dlsym(handle, function_name.c_str());
#endif

        if (!func)
        {
            std::cerr << "Symbol '" << function_name << "' not found in " << path << std::endl;
            return nullptr;
        }

        return reinterpret_cast<Func *>(func);
    }

    template <typename Func>
    Func *operator()(const std::string &function_name) const
    {
        return get<Func>(function_name);
    }

    operator bool() const { return handle != nullptr; }

    const std::string &name() const { return path; }
};

inline DLL load(const std::string &dll_path)
{
    return DLL(dll_path);
}

class DLLManager
{
private:
    std::unordered_map<std::string, DLL> dlls;

public:
    DLL &load(const std::string &name, const std::string &path)
    {
        return dlls.emplace(name, DLL(path)).first->second;
    }

    DLL &get(const std::string &name)
    {
        auto it = dlls.find(name);
        if (it == dlls.end())
            throw std::runtime_error("DLL not loaded: " + name);
        return it->second;
    }

    void unload(const std::string &name)
    {
        dlls.erase(name);
    }

    bool has(const std::string &name) const
    {
        return dlls.find(name) != dlls.end();
    }

    void clear()
    {
        dlls.clear();
    }
};

inline DLLManager &dlls()
{
    static DLLManager manager;
    return manager;
}

inline DLL &load_to(const std::string &name, const std::string &path)
{
    return dlls().load(name, path);
}

} 

#define EASY_DLL(var_name, dll_path) auto var_name = stddll::load(dll_path)

#define GET_FUNC(dll, return_type, func_name, ...) \
    dll.get<return_type (*)(__VA_ARGS__)>(#func_name)

#define CALL(dll, func, ...) \
    dll.get<decltype(func) *>(#func)(__VA_ARGS__)

#endif
